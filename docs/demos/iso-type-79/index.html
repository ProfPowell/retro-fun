<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Iso Type 79 // RETRO FUN</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; overflow: hidden; font-family: 'Courier New', monospace; }
  canvas { display: block; }
  .back {
    position: fixed; top: 1rem; right: 1rem;
    font-family: 'Courier New', monospace; font-size: 0.7rem;
    color: #555; text-decoration: none; letter-spacing: 0.15em;
    text-transform: uppercase; z-index: 10;
  }
  .back:hover { color: #ff00ff; }

  .panel {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: rgba(10, 10, 20, 0.92);
    border-top: 1px solid #333;
    padding: 1rem 1.5rem;
    display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;
    z-index: 10; backdrop-filter: blur(8px);
  }
  .panel label {
    color: #666; font-size: 0.65rem; letter-spacing: 0.15em; text-transform: uppercase;
  }
  .panel input[type="text"] {
    background: #111; border: 1px solid #333; color: #fff;
    font-family: 'Courier New', monospace; font-size: 1rem;
    padding: 0.4rem 0.6rem; width: 200px; letter-spacing: 0.1em;
  }
  .panel input[type="text"]:focus { border-color: #ff00ff; outline: none; }
  .scheme-btn {
    background: none; border: 1px solid #333; color: #666;
    font-family: 'Courier New', monospace; font-size: 0.6rem;
    padding: 0.35rem 0.6rem; cursor: pointer; letter-spacing: 0.08em;
    text-transform: uppercase; transition: all 0.2s;
  }
  .scheme-btn:hover { border-color: #888; color: #aaa; }
  .scheme-btn.active { border-color: var(--accent, #ff00ff); color: var(--accent, #ff00ff); }
  .scheme-swatch {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%;
    margin-right: 4px; vertical-align: middle;
  }
</style>
</head>
<body>
<a class="back" href="../../">&larr; Back</a>
<canvas id="c"></canvas>

<div class="panel">
  <div>
    <label>Text</label><br>
    <input type="text" id="textInput" value="RETRO" maxlength="12" spellcheck="false">
  </div>
  <div>
    <label>Color Scheme</label><br>
    <div id="schemeButtons" style="display: flex; gap: 0.4rem; flex-wrap: wrap; margin-top: 0.3rem;"></div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Color schemes
const schemes = {
  '70s Groovy': {
    bg: '#2d1b00',
    colors: ['#ff6f00', '#e65100', '#bf360c', '#8d6e63', '#ffcc02', '#c6a700'],
    accent: '#ff6f00',
    shadow: '#3e2723',
    grid: '#4e342e',
  },
  'Disco': {
    bg: '#1a0033',
    colors: ['#ff00ff', '#ffff00', '#00ffff', '#ff4400', '#ff88ff', '#88ffff'],
    accent: '#ff00ff',
    shadow: '#330066',
    grid: '#440088',
  },
  'Miami 80s': {
    bg: '#0d1b2a',
    colors: ['#ff006e', '#00f5d4', '#fee440', '#f15bb5', '#00bbf9', '#9b5de5'],
    accent: '#ff006e',
    shadow: '#1b2838',
    grid: '#1e3a5f',
  },
  'Nagel 80s': {
    bg: '#1a1a1a',
    colors: ['#e63946', '#f1faee', '#a8dadc', '#457b9d', '#ff69b4', '#2d2d2d'],
    accent: '#e63946',
    shadow: '#2d2d2d',
    grid: '#333333',
  },
  'Vaporwave': {
    bg: '#0a0020',
    colors: ['#ff71ce', '#01cdfe', '#05ffa1', '#b967ff', '#fffb96', '#ff71ce'],
    accent: '#ff71ce',
    shadow: '#1a0040',
    grid: '#220055',
  },
  'Cyberpunk': {
    bg: '#0a0a0a',
    colors: ['#00ff41', '#ff0040', '#fffc00', '#0080ff', '#ff00ff', '#00ffff'],
    accent: '#00ff41',
    shadow: '#111111',
    grid: '#1a1a1a',
  },
};

let currentScheme = 'Disco';
let userText = 'RETRO';
let time = 0;

// Build scheme buttons
const btnContainer = document.getElementById('schemeButtons');
Object.keys(schemes).forEach(name => {
  const btn = document.createElement('button');
  btn.className = 'scheme-btn' + (name === currentScheme ? ' active' : '');
  btn.style.setProperty('--accent', schemes[name].accent);

  const swatch = document.createElement('span');
  swatch.className = 'scheme-swatch';
  swatch.style.background = schemes[name].accent;
  btn.appendChild(swatch);
  btn.appendChild(document.createTextNode(name));

  btn.addEventListener('click', () => {
    document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentScheme = name;
  });
  btnContainer.appendChild(btn);
});

document.getElementById('textInput').addEventListener('input', (e) => {
  userText = e.target.value.toUpperCase() || 'RETRO';
});

// Isometric projection helpers
function isoProject(x, y, z) {
  // Classic isometric: 30-degree angles
  const isoX = (x - y) * Math.cos(Math.PI / 6);
  const isoY = (x + y) * Math.sin(Math.PI / 6) - z;
  return { x: isoX, y: isoY };
}

// Flying text copies with 3D paths
const copies = [];
const MAX_COPIES = 40;

function spawnCopy() {
  const scheme = schemes[currentScheme];
  const color = scheme.colors[Math.floor(Math.random() * scheme.colors.length)];
  copies.push({
    text: userText,
    x: (Math.random() - 0.5) * 600,
    y: (Math.random() - 0.5) * 600,
    z: -200 - Math.random() * 400,
    vx: (Math.random() - 0.5) * 2,
    vy: (Math.random() - 0.5) * 2,
    vz: 1.5 + Math.random() * 2,
    rotPhase: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.02,
    scale: 0.5 + Math.random() * 1.5,
    color,
    alpha: 0,
    born: time,
  });
}

// Pre-seed
for (let i = 0; i < 20; i++) {
  spawnCopy();
  copies[copies.length - 1].z = -600 + Math.random() * 800;
  copies[copies.length - 1].alpha = 0.7;
}

function drawIsoGrid(scheme) {
  const cx = W / 2;
  const cy = H / 2 + 50;
  const gridSize = 20;
  const spacing = 40;

  ctx.strokeStyle = scheme.grid + '40';
  ctx.lineWidth = 0.5;

  for (let i = -gridSize; i <= gridSize; i++) {
    // Lines along X axis
    const start = isoProject(i * spacing, -gridSize * spacing, 0);
    const end = isoProject(i * spacing, gridSize * spacing, 0);
    ctx.beginPath();
    ctx.moveTo(cx + start.x, cy + start.y);
    ctx.lineTo(cx + end.x, cy + end.y);
    ctx.stroke();

    // Lines along Y axis
    const start2 = isoProject(-gridSize * spacing, i * spacing, 0);
    const end2 = isoProject(gridSize * spacing, i * spacing, 0);
    ctx.beginPath();
    ctx.moveTo(cx + start2.x, cy + start2.y);
    ctx.lineTo(cx + end2.x, cy + end2.y);
    ctx.stroke();
  }
}

function draw3DChar(ch, x, y, size, color, alpha, shadowColor) {
  // 1979-style 3D block letters with depth
  const depth = size * 0.15;
  const steps = Math.max(3, Math.floor(depth / 2));

  ctx.save();
  ctx.globalAlpha = alpha;

  // Shadow / extrusion layers
  for (let d = steps; d >= 0; d--) {
    const t = d / steps;
    const ox = d * 1.5;
    const oy = d * 1.5;

    if (d > 0) {
      // Extrusion - darker shade
      ctx.fillStyle = shadowColor;
      ctx.font = `bold ${size}px 'Courier New', monospace`;
      ctx.fillText(ch, x + ox, y + oy);
    } else {
      // Front face
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      ctx.font = `bold ${size}px 'Courier New', monospace`;
      ctx.fillText(ch, x, y);
      ctx.shadowBlur = 0;

      // Highlight line on top
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillText(ch, x, y - 1);
    }
  }

  ctx.restore();
}

function draw() {
  const scheme = schemes[currentScheme];

  // Background
  ctx.fillStyle = scheme.bg;
  ctx.fillRect(0, 0, W, H);

  // Isometric grid (scrolling)
  ctx.save();
  const gridOffset = (time * 20) % 40;
  ctx.translate(gridOffset * Math.cos(Math.PI / 6), gridOffset * Math.sin(Math.PI / 6));
  drawIsoGrid(scheme);
  ctx.restore();

  // Spawn new copies
  if (copies.length < MAX_COPIES && Math.random() < 0.03) {
    spawnCopy();
  }

  const cx = W / 2;
  const cy = H / 2;

  // Sort copies by Z for correct depth ordering
  copies.sort((a, b) => a.z - b.z);

  // Draw flying text copies
  for (let i = copies.length - 1; i >= 0; i--) {
    const c = copies[i];

    // Update position
    c.x += c.vx;
    c.y += c.vy;
    c.z += c.vz;
    c.rotPhase += c.rotSpeed;

    // Fade in
    if (c.alpha < 0.9) c.alpha += 0.01;

    // Remove if too far
    if (c.z > 400) {
      copies.splice(i, 1);
      continue;
    }

    // Isometric projection
    const orbX = c.x + Math.sin(time * 0.5 + c.rotPhase) * 100;
    const orbY = c.y + Math.cos(time * 0.3 + c.rotPhase) * 100;
    const proj = isoProject(orbX, orbY, c.z);

    // Depth-based sizing
    const depthFactor = 1 + c.z / 300;
    const fontSize = Math.max(8, 28 * c.scale * Math.max(0.2, depthFactor));
    const alpha = c.alpha * Math.max(0.1, Math.min(1, 1 - Math.abs(c.z) / 500));

    if (alpha < 0.05 || fontSize < 5) continue;

    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const textX = cx + proj.x;
    const textY = cy + proj.y;

    // Draw each character with 3D extrusion
    const text = c.text;
    const charWidth = fontSize * 0.65;
    const startX = textX - (text.length * charWidth) / 2;

    for (let ci = 0; ci < text.length; ci++) {
      const charX = startX + ci * charWidth;
      // Per-character wave
      const wave = Math.sin(time * 3 + ci * 0.5 + c.rotPhase) * fontSize * 0.1;

      draw3DChar(text[ci], charX, textY + wave, fontSize, c.color, alpha, scheme.shadow);
    }

    ctx.restore();
  }

  // Main text - large, center, with heavy 3D
  const mainSize = Math.min(W * 0.12, 120);
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const mainText = userText;
  const mainCharWidth = mainSize * 0.65;
  const mainStartX = cx - (mainText.length * mainCharWidth) / 2;

  for (let ci = 0; ci < mainText.length; ci++) {
    const charX = mainStartX + ci * mainCharWidth;
    const bounce = Math.sin(time * 2 + ci * 0.4) * 10;
    const color = scheme.colors[ci % scheme.colors.length];

    // Heavy 3D extrusion for main text
    const depth = 12;
    for (let d = depth; d >= 0; d--) {
      const t = d / depth;
      ctx.font = `bold ${mainSize}px 'Courier New', monospace`;
      if (d > 0) {
        ctx.fillStyle = scheme.shadow;
        ctx.globalAlpha = 0.8;
        ctx.fillText(mainText[ci], charX + d * 2, cy + bounce + d * 2);
      } else {
        ctx.globalAlpha = 1;
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 20;
        ctx.fillText(mainText[ci], charX, cy + bounce);
        ctx.shadowBlur = 0;

        // Chrome highlight
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#fff';
        ctx.fillText(mainText[ci], charX, cy + bounce - 2);
      }
    }
  }
  ctx.restore();

  // Scanlines
  ctx.fillStyle = 'rgba(0,0,0,0.04)';
  for (let y = 0; y < H; y += 3) {
    ctx.fillRect(0, y, W, 1);
  }

  // Year badge
  ctx.save();
  ctx.font = 'bold 14px monospace';
  ctx.fillStyle = scheme.accent + '44';
  ctx.textAlign = 'left';
  ctx.fillText('EST. 1979', 20, 30);
  ctx.restore();

  time += 0.016;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
