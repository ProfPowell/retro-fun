<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Div Vaders // RETRO FUN</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    font-family: 'Courier New', monospace;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  canvas { display: block; image-rendering: pixelated; }
  .back {
    position: fixed; top: 0.8rem; right: 0.8rem;
    font-family: 'Courier New', monospace; font-size: 0.85rem;
    color: #444; text-decoration: none; letter-spacing: 0.15em;
    text-transform: uppercase; z-index: 30;
    padding: 0.4rem 0.6rem;
  }
  .back:hover { color: #00ffff; }

  /* ===== TOUCH CONTROLS ===== */
  #touch-ui {
    display: none;
    position: fixed;
    bottom: 0; left: 0; right: 0;
    z-index: 20;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }
  #touch-ui.visible { display: flex; }

  .touch-btn {
    flex: 1;
    height: 72px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    font-size: 28px;
    border: none;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.05s;
  }
  .touch-btn-move {
    color: #00ccdd;
    background: rgba(0, 200, 220, 0.06);
    border-top: 1px solid rgba(0, 200, 220, 0.15);
  }
  .touch-btn-move.active {
    background: rgba(0, 200, 220, 0.2);
  }
  .touch-btn-fire {
    flex: 1.5;
    color: #ff4466;
    background: rgba(255, 50, 80, 0.08);
    border-top: 1px solid rgba(255, 50, 80, 0.2);
    font-size: 22px;
    letter-spacing: 0.15em;
  }
  .touch-btn-fire.active {
    background: rgba(255, 50, 80, 0.25);
  }

  @media (min-height: 700px) {
    .touch-btn { height: 84px; }
  }
  @media (min-height: 900px) {
    .touch-btn { height: 96px; }
  }
</style>
</head>
<body>
<a class="back" href="../../">&larr; Back</a>
<canvas id="c"></canvas>

<div id="touch-ui">
  <div class="touch-btn touch-btn-move" id="btn-left">&laquo;</div>
  <div class="touch-btn touch-btn-fire" id="btn-fire">FIRE</div>
  <div class="touch-btn touch-btn-move" id="btn-right">&raquo;</div>
</div>

<script>
// =====================================================================
// DIV VADERS - The Markup Battle
// Can you save the web from meaningless divs and obsolete tags?
// =====================================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

// =====================================================================
// RESPONSIVE SCALING
// =====================================================================

let S = 1;           // UI scale factor
let gameBottom;      // effective bottom of play area (above touch controls)
let touchH = 0;     // height of touch control bar
let isMobile = false;

const touchUI = document.getElementById('touch-ui');

function detectMobile() {
  return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (W < 700);
}

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;

  isMobile = detectMobile();

  // Scale factor: ensures text is readable on small screens
  const minDim = Math.min(W, H);
  S = Math.min(2.5, Math.max(1, 580 / minDim));

  // Touch control height
  if (isMobile) {
    const btn = document.querySelector('.touch-btn');
    touchH = btn ? btn.offsetHeight : 80;
    touchUI.classList.add('visible');
  } else {
    touchH = 0;
    touchUI.classList.remove('visible');
  }

  gameBottom = H - touchH;
}
window.addEventListener('resize', resize);
resize();

// Scaled font size helper
function fs(px) { return Math.round(px * S); }

// =====================================================================
// AUDIO ENGINE - 8-bit sound effects via Web Audio API
// =====================================================================

let audioCtx;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;

  switch (type) {
    case 'shoot': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(1200, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.08);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.08);
      break;
    }
    case 'hit-bad': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, now);
      osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
      gain.gain.setValueAtTime(0.12, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.2);
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.08, now);
      ng.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      src.connect(ng); ng.connect(audioCtx.destination);
      src.start(now); src.stop(now + 0.1);
      break;
    }
    case 'hit-good': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(520, now);
      osc.frequency.linearRampToValueAtTime(180, now + 0.35);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.35);
      break;
    }
    case 'hit-armor': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(600, now);
      osc.frequency.setValueAtTime(800, now + 0.03);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.06);
      break;
    }
    case 'enemy-fire': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(180, now);
      osc.frequency.exponentialRampToValueAtTime(90, now + 0.15);
      gain.gain.setValueAtTime(0.05, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.15);
      break;
    }
    case 'player-die': {
      for (let k = 0; k < 4; k++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300 - k * 50, now + k * 0.1);
        osc.frequency.exponentialRampToValueAtTime(20, now + k * 0.1 + 0.2);
        gain.gain.setValueAtTime(0.1, now + k * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, now + k * 0.1 + 0.2);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(now + k * 0.1); osc.stop(now + k * 0.1 + 0.2);
      }
      break;
    }
    case 'wave-clear': {
      [523, 659, 784, 1047].forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.value = f;
        gain.gain.setValueAtTime(0, now + i * 0.12);
        gain.gain.linearRampToValueAtTime(0.07, now + i * 0.12 + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.3);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(now + i * 0.12); osc.stop(now + i * 0.12 + 0.3);
      });
      break;
    }
    case 'game-over': {
      [440, 370, 311, 262].forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = f;
        gain.gain.setValueAtTime(0, now + i * 0.3);
        gain.gain.linearRampToValueAtTime(0.1, now + i * 0.3 + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.3 + 0.5);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(now + i * 0.3); osc.stop(now + i * 0.3 + 0.5);
      });
      break;
    }
    case 'saucer-hum': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(440, now);
      osc.frequency.setValueAtTime(490, now + 0.06);
      osc.frequency.setValueAtTime(440, now + 0.12);
      gain.gain.setValueAtTime(0.04, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.12);
      break;
    }
    case 'saucer-drop': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(660, now);
      osc.frequency.exponentialRampToValueAtTime(120, now + 0.12);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.12);
      break;
    }
    case 'meter-warn': {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(220, now);
      osc.frequency.setValueAtTime(260, now + 0.08);
      osc.frequency.setValueAtTime(220, now + 0.16);
      gain.gain.setValueAtTime(0.05, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.2);
      break;
    }
  }
}

// =====================================================================
// TAG DATA
// =====================================================================

const GOOD_TAGS = [
  '<header>', '<nav>', '<main>', '<section>', '<article>',
  '<aside>', '<footer>', '<figure>', '<details>', '<summary>',
  '<time>', '<mark>', '<address>', '<output>', '<dialog>',
  '<figcaption>', '<abbr>', '<cite>', '<blockquote>',
];

const BAD_TAGS_OBSOLETE = [
  '<font>', '<center>', '<blink>', '<spacer>',
  '<big>', '<tt>', '<strike>', '<frame>',
  '<frameset>', '<applet>', '<basefont>', '<isindex>',
  '<acronym>', '<dir>', '<xmp>',
];

function randomBadTag() {
  if (Math.random() < 0.6) return '<div>';
  return BAD_TAGS_OBSOLETE[Math.floor(Math.random() * BAD_TAGS_OBSOLETE.length)];
}

function randomGoodTag() {
  return GOOD_TAGS[Math.floor(Math.random() * GOOD_TAGS.length)];
}

// =====================================================================
// GAME STATE
// =====================================================================

const STATE = { TITLE: 0, PLAYING: 1, DYING: 2, WAVE_CLEAR: 3, GAME_OVER: 4 };
let gameState = STATE.TITLE;
let score = 0;
let highScore = parseInt(localStorage.getItem('divvaders-hi') || '0', 10);
let wave = 0;
let techDebt = 0;
let semantics = 100;
let meterWarnTimer = 0;

let player = { x: 0, y: 0, w: 56, h: 22, alive: true, flash: 0, deathTimer: 0 };

let playerBullets = [];
let enemyBullets = [];
let shootCooldown = 0;

let enemies = [];
let formationX = 0, formationY = 0;
let formationDir = 1;
let formationSpeed = 0.4;
let moveTimer = 0;
let moveInterval = 40;
let enemyShootTimer = 0;

let saucer = null;
let saucerTimer = 0;
let saucerDrops = [];
let saucerHumTimer = 0;

let particles = [];

let shakeX = 0, shakeY = 0, shakeMag = 0;

let waveClearTimer = 0;
let titleBlink = 0;
let titleStars = [];
for (let i = 0; i < 120; i++) {
  titleStars.push({
    x: Math.random(), y: Math.random(),
    speed: 0.0005 + Math.random() * 0.002,
    bright: Math.random(),
  });
}

let flashMessages = [];

// =====================================================================
// INPUT - Keyboard + Touch
// =====================================================================

const keys = {};

// Touch button states
const touch = { left: false, right: false, fire: false };

window.addEventListener('keydown', e => {
  keys[e.key] = true;
  keys[e.code] = true;
  if (['Space', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
    e.preventDefault();
  }
  if (gameState === STATE.TITLE && (e.code === 'Space' || e.code === 'Enter')) {
    initAudio();
    startGame();
  }
  if (gameState === STATE.GAME_OVER && (e.code === 'Space' || e.code === 'Enter')) {
    gameState = STATE.TITLE;
    titleBlink = 0;
  }
});

window.addEventListener('keyup', e => {
  keys[e.key] = false;
  keys[e.code] = false;
});

// Canvas tap for title/game-over
canvas.addEventListener('click', () => {
  if (gameState === STATE.TITLE) {
    initAudio();
    startGame();
  } else if (gameState === STATE.GAME_OVER) {
    gameState = STATE.TITLE;
    titleBlink = 0;
  }
});

// --- Touch control wiring ---
function setupTouchButton(id, stateKey) {
  const el = document.getElementById(id);
  if (!el) return;

  function activate(e) {
    e.preventDefault();
    e.stopPropagation();
    initAudio();
    touch[stateKey] = true;
    el.classList.add('active');
    // Also handle title/game-over transitions from any button
    if (gameState === STATE.TITLE) { startGame(); }
    else if (gameState === STATE.GAME_OVER) { gameState = STATE.TITLE; titleBlink = 0; }
  }
  function deactivate(e) {
    e.preventDefault();
    e.stopPropagation();
    touch[stateKey] = false;
    el.classList.remove('active');
  }

  el.addEventListener('pointerdown', activate, { passive: false });
  el.addEventListener('pointerup', deactivate, { passive: false });
  el.addEventListener('pointercancel', deactivate, { passive: false });
  el.addEventListener('pointerleave', deactivate, { passive: false });

  // Prevent context menu on long-press
  el.addEventListener('contextmenu', e => e.preventDefault());
}

setupTouchButton('btn-left', 'left');
setupTouchButton('btn-right', 'right');
setupTouchButton('btn-fire', 'fire');

// Helper: is a direction/action active (keyboard OR touch)
function inputLeft() { return keys['ArrowLeft'] || keys['a'] || keys['A'] || touch.left; }
function inputRight() { return keys['ArrowRight'] || keys['d'] || keys['D'] || touch.right; }
function inputFire() { return keys['Space'] || keys['ArrowUp'] || keys['w'] || keys['W'] || touch.fire; }

// =====================================================================
// GAME LOGIC
// =====================================================================

function startGame() {
  gameState = STATE.PLAYING;
  score = 0;
  wave = 0;
  techDebt = 0;
  semantics = 100;
  player.alive = true;
  player.flash = 0;
  player.x = W / 2;
  player.y = gameBottom - 28;
  playerBullets = [];
  enemyBullets = [];
  enemies = [];
  particles = [];
  flashMessages = [];
  saucer = null;
  saucerDrops = [];
  saucerTimer = 400;
  shakeMag = 0;
  spawnWave();
}

function spawnWave() {
  wave++;
  enemies = [];
  enemyBullets = [];
  saucerDrops = [];

  // Fewer columns on narrow screens
  const maxCols = W < 450 ? 5 : W < 650 ? 7 : 11;
  const cols = Math.min(maxCols, 6 + Math.floor(wave * 0.4));
  const maxRows = gameBottom < 500 ? 3 : 5;
  const rows = Math.min(maxRows, 3 + Math.floor(wave * 0.2));

  // Tag cell sizing - fit to screen width
  const gapX = Math.round(5 * S);
  const gapY = Math.round(5 * S);
  const tagW = Math.min(Math.round(72 * S), Math.floor((W - 40) / cols - gapX));
  const tagH = Math.round(28 * S);

  const badRatio = Math.min(0.85, 0.3 + wave * 0.045);

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const isBad = Math.random() < badRatio;
      const tag = isBad ? randomBadTag() : randomGoodTag();
      const isObsolete = isBad && tag !== '<div>';

      enemies.push({
        tag, bad: isBad,
        col: c, row: r,
        localX: c * (tagW + gapX),
        localY: r * (tagH + gapY),
        w: tagW, h: tagH,
        alive: true,
        flash: 0,
        hp: isObsolete ? 2 : 1,
        maxHp: isObsolete ? 2 : 1,
        points: isBad ? (tag === '<div>' ? 10 : 30) : -20,
      });
    }
  }

  const formW = cols * (tagW + gapX);
  formationX = (W - formW) / 2;
  formationY = Math.round(50 * S);
  formationDir = 1;
  formationSpeed = 0.3 + wave * 0.1;
  moveInterval = Math.max(6, 35 - wave * 2);
  moveTimer = 0;
  enemyShootTimer = 0;
  if (!saucer) saucerTimer = 200 + Math.random() * 200;
}

function addFlash(text, x, y, color) {
  flashMessages.push({ text, x, y, color, life: 1 });
}

function spawnExplosion(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 4;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 1,
      life: 1,
      decay: 0.015 + Math.random() * 0.02,
      size: (2 + Math.random() * 4) * S,
      color,
    });
  }
}

function spawnTextDebris(text, x, y, color) {
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (ch === '<' || ch === '>' || ch === ' ') continue;
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
    const speed = 2 + Math.random() * 3;
    particles.push({
      x: x + (i - text.length / 2) * 6 * S,
      y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.01 + Math.random() * 0.01,
      size: fs(9),
      color,
      char: ch,
    });
  }
}

function playerHit() {
  if (!player.alive || player.flash > 0) return;
  player.alive = false;
  player.deathTimer = 90;
  gameState = STATE.DYING;
  spawnExplosion(player.x, player.y, '#00ffff', 20);
  spawnTextDebris('<body>', player.x, player.y, '#00ffff');
  shakeMag = 8;
  playSound('player-die');
}

function checkGameOver() {
  if (techDebt >= 100 && semantics <= 0) {
    gameState = STATE.GAME_OVER;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('divvaders-hi', String(highScore));
    }
    playSound('game-over');
  }
}

function update() {
  // Shake decay
  if (shakeMag > 0) {
    shakeX = (Math.random() - 0.5) * shakeMag;
    shakeY = (Math.random() - 0.5) * shakeMag;
    shakeMag *= 0.9;
    if (shakeMag < 0.3) { shakeMag = 0; shakeX = 0; shakeY = 0; }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Update flash messages
  for (let i = flashMessages.length - 1; i >= 0; i--) {
    flashMessages[i].life -= 0.025;
    flashMessages[i].y -= 0.8;
    if (flashMessages[i].life <= 0) flashMessages.splice(i, 1);
  }

  // Wave clear state
  if (gameState === STATE.WAVE_CLEAR) {
    waveClearTimer--;
    if (waveClearTimer <= 0) {
      techDebt = Math.max(0, techDebt - 25);
      semantics = Math.min(100, semantics + 25);
      spawnWave();
      gameState = STATE.PLAYING;
    }
    return;
  }

  // Dying state
  if (gameState === STATE.DYING) {
    player.deathTimer--;
    if (player.deathTimer <= 0) {
      player.alive = true;
      player.flash = 90;
      player.x = W / 2;
      gameState = STATE.PLAYING;
    }
  }

  // Meter warning
  if (techDebt > 75 || semantics < 25) {
    meterWarnTimer++;
    if (meterWarnTimer % 180 === 0) playSound('meter-warn');
  } else {
    meterWarnTimer = 0;
  }

  // --- Player ---
  if (player.alive) {
    const speed = 5 * S;
    if (inputLeft()) player.x -= speed;
    if (inputRight()) player.x += speed;
    player.x = Math.max(player.w / 2, Math.min(W - player.w / 2, player.x));
    player.y = gameBottom - 28 * S;

    if (player.flash > 0) player.flash--;

    if (shootCooldown > 0) shootCooldown--;
    if (inputFire() && shootCooldown === 0) {
      if (playerBullets.length < 3) {
        playerBullets.push({
          x: player.x,
          y: player.y - player.h / 2 - 6 * S,
          vy: -9,
        });
        shootCooldown = 10;
        playSound('shoot');
      }
    }
  }

  // Player ship size (scales with S)
  player.w = Math.round(56 * S);
  player.h = Math.round(22 * S);

  // --- Player bullets ---
  for (let i = playerBullets.length - 1; i >= 0; i--) {
    playerBullets[i].y += playerBullets[i].vy;
    if (playerBullets[i].y < -20) { playerBullets.splice(i, 1); continue; }

    const b = playerBullets[i];
    if (!b) continue;
    let hit = false;

    for (const e of enemies) {
      if (!e.alive) continue;
      const ex = formationX + e.localX;
      const ey = formationY + e.localY;
      if (b.x > ex - 2 && b.x < ex + e.w + 2 && b.y > ey - 2 && b.y < ey + e.h + 2) {
        e.hp--;
        if (e.hp <= 0) {
          e.alive = false;
          score = Math.max(0, score + e.points);
          if (e.bad) {
            playSound('hit-bad');
            spawnExplosion(ex + e.w / 2, ey + e.h / 2, '#ff4444', 10);
            spawnTextDebris(e.tag, ex + e.w / 2, ey + e.h / 2, '#ff6644');
            addFlash('+' + Math.abs(e.points), ex + e.w / 2, ey, '#ffff00');
          } else {
            playSound('hit-good');
            semantics = Math.max(0, semantics - 3);
            techDebt = Math.min(100, techDebt + 2);
            spawnExplosion(ex + e.w / 2, ey + e.h / 2, '#00ff88', 6);
            addFlash('FRIENDLY FIRE!', ex + e.w / 2, ey, '#ff8800');
            addFlash(e.points.toString(), ex + e.w / 2, ey + 16, '#ff4444');
            checkGameOver();
          }
        } else {
          e.flash = 8;
          playSound('hit-armor');
          addFlash('ARMOR!', ex + e.w / 2, ey, '#ffaa44');
        }
        hit = true;
        break;
      }
    }

    if (!hit && saucer) {
      if (b.x > saucer.x - saucer.w / 2 && b.x < saucer.x + saucer.w / 2 &&
          b.y > saucer.y - 12 * S && b.y < saucer.y + 12 * S) {
        score += 50;
        addFlash('+50', saucer.x, saucer.y - 15, '#ff00ff');
        spawnExplosion(saucer.x, saucer.y, '#ff00ff', 15);
        spawnTextDebris('<marquee>', saucer.x, saucer.y, '#ff88ff');
        playSound('hit-bad');
        saucer = null;
        hit = true;
      }
    }

    if (!hit) {
      for (let di = saucerDrops.length - 1; di >= 0; di--) {
        const d = saucerDrops[di];
        if (Math.abs(b.x - d.x) < 22 * S && Math.abs(b.y - d.y) < 14 * S) {
          score += 5;
          addFlash('+5', d.x, d.y - 10, '#ffff00');
          spawnExplosion(d.x, d.y, '#ff4444', 5);
          playSound('hit-bad');
          saucerDrops.splice(di, 1);
          hit = true;
          break;
        }
      }
    }

    if (hit) playerBullets.splice(i, 1);
  }

  // --- Enemy formation movement ---
  moveTimer++;
  if (moveTimer >= moveInterval) {
    moveTimer = 0;

    let minX = Infinity, maxX = -Infinity;
    let aliveCount = 0;
    for (const e of enemies) {
      if (!e.alive) continue;
      aliveCount++;
      const ex = formationX + e.localX;
      minX = Math.min(minX, ex);
      maxX = Math.max(maxX, ex + e.w);
    }

    if (aliveCount > 0) {
      const speedMult = 1 + (1 - aliveCount / enemies.length) * 2;
      const stepX = formationDir * formationSpeed * 8 * speedMult;
      const nextMin = minX + stepX;
      const nextMax = maxX + stepX;

      if (nextMax > W - 10 || nextMin < 10) {
        formationDir *= -1;
        formationY += Math.round(10 * S);
      } else {
        formationX += stepX;
      }
    }
  }

  // --- Enemy shooting ---
  enemyShootTimer++;
  const shootInterval = Math.max(25, 100 - wave * 8);
  if (enemyShootTimer >= shootInterval && gameState === STATE.PLAYING) {
    enemyShootTimer = 0;
    const colBottoms = {};
    for (const e of enemies) {
      if (!e.alive) continue;
      if (!colBottoms[e.col] || e.row > colBottoms[e.col].row) {
        colBottoms[e.col] = e;
      }
    }
    const shooters = Object.values(colBottoms);
    if (shooters.length > 0) {
      const s = shooters[Math.floor(Math.random() * shooters.length)];
      const ex = formationX + s.localX + s.w / 2;
      const ey = formationY + s.localY + s.h;
      enemyBullets.push({
        x: ex, y: ey,
        vy: 3.5 + wave * 0.25,
        tag: s.tag, bad: s.bad,
      });
      playSound('enemy-fire');
    }
  }

  // --- Enemy bullets ---
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const b = enemyBullets[i];
    b.y += b.vy;
    if (b.y > gameBottom + 20) { enemyBullets.splice(i, 1); continue; }

    if (player.alive && player.flash === 0) {
      if (Math.abs(b.x - player.x) < player.w / 2 + 3 &&
          Math.abs(b.y - player.y) < player.h / 2 + 5) {
        enemyBullets.splice(i, 1);
        playerHit();
        continue;
      }
    }

    if (b.y > gameBottom - 8 && b.bad) {
      techDebt = Math.min(100, techDebt + 1);
      semantics = Math.max(0, semantics - 0.5);
      spawnExplosion(b.x, gameBottom - 8, '#ff444466', 3);
      enemyBullets.splice(i, 1);
      checkGameOver();
    }
  }

  // --- Saucer drops ---
  for (let i = saucerDrops.length - 1; i >= 0; i--) {
    const d = saucerDrops[i];
    d.y += d.vy;
    d.vy += 0.04;
    d.wobble = (d.wobble || 0) + 0.15;
    d.x += Math.sin(d.wobble) * 0.5;

    if (d.y > gameBottom + 30) { saucerDrops.splice(i, 1); continue; }

    if (player.alive && player.flash === 0) {
      if (Math.abs(d.x - player.x) < player.w / 2 + 16 &&
          Math.abs(d.y - player.y) < player.h / 2 + 10) {
        saucerDrops.splice(i, 1);
        playerHit();
        continue;
      }
    }

    if (saucerDrops[i] && d.y > gameBottom - 8) {
      techDebt = Math.min(100, techDebt + 2);
      semantics = Math.max(0, semantics - 1);
      spawnExplosion(d.x, gameBottom - 8, '#ff4444', 4);
      addFlash('<div> LANDED!', d.x, gameBottom - 22, '#ff4444');
      saucerDrops.splice(i, 1);
      checkGameOver();
    }
  }

  // --- Enemies reaching the ground ---
  for (const e of enemies) {
    if (!e.alive) continue;
    const ey = formationY + e.localY + e.h;
    if (ey > gameBottom - 18 * S) {
      if (e.bad) {
        techDebt = Math.min(100, techDebt + 4);
        semantics = Math.max(0, semantics - 3);
        addFlash('INVADED!', formationX + e.localX + e.w / 2, gameBottom - 28 * S, '#ff0000');
      }
      e.alive = false;
      spawnExplosion(formationX + e.localX + e.w / 2, ey, e.bad ? '#ff0000' : '#00ff00', 4);
      shakeMag = Math.max(shakeMag, 3);
      checkGameOver();
    }
  }

  // --- Saucer ---
  saucerTimer--;
  if (saucerTimer <= 0 && !saucer && gameState === STATE.PLAYING) {
    const dir = Math.random() > 0.5 ? 1 : -1;
    saucer = {
      x: dir > 0 ? -90 : W + 90,
      y: Math.round(32 * S),
      dir, speed: 1.5 + wave * 0.15,
      w: Math.round(90 * S),
      dropTimer: 40 + Math.random() * 30,
      dropInterval: Math.max(15, 45 - wave * 2),
    };
    saucerTimer = 500 + Math.random() * 500;
  }

  if (saucer) {
    saucer.x += saucer.dir * saucer.speed;
    saucerHumTimer++;
    if (saucerHumTimer % 20 === 0) playSound('saucer-hum');

    saucer.dropTimer--;
    if (saucer.dropTimer <= 0 && gameState === STATE.PLAYING) {
      saucer.dropTimer = saucer.dropInterval;
      saucerDrops.push({
        x: saucer.x, y: saucer.y + 14,
        vy: 1.5 + wave * 0.1,
        wobble: Math.random() * Math.PI * 2,
      });
      playSound('saucer-drop');
    }

    if ((saucer.dir > 0 && saucer.x > W + 120) ||
        (saucer.dir < 0 && saucer.x < -120)) {
      saucer = null;
      saucerHumTimer = 0;
    }
  }

  // --- Check wave clear ---
  const aliveBad = enemies.filter(e => e.alive && e.bad);
  if (aliveBad.length === 0 && enemies.length > 0 && gameState === STATE.PLAYING) {
    for (const e of enemies) {
      if (e.alive) {
        e.alive = false;
        const ex = formationX + e.localX + e.w / 2;
        const ey = formationY + e.localY + e.h / 2;
        spawnExplosion(ex, ey, '#00ff88', 3);
      }
    }
    gameState = STATE.WAVE_CLEAR;
    waveClearTimer = 150;
    saucerDrops = [];
    enemyBullets = [];
    playSound('wave-clear');
  }
}

// =====================================================================
// RENDERING
// =====================================================================

function drawTag(text, x, y, w, h, bad, flash, hp, maxHp) {
  const baseColor = bad ? '#ff2244' : '#00cc66';
  const bgColor = bad ? (flash > 0 ? '#660022' : '#220011') : (flash > 0 ? '#005522' : '#001a0a');
  const borderColor = flash > 0 ? '#ffffff' : (bad ? '#ff446688' : '#00ff8866');

  ctx.fillStyle = bgColor;
  ctx.fillRect(x, y, w, h);

  ctx.strokeStyle = borderColor;
  ctx.lineWidth = flash > 0 ? 2 : 1;
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

  if (maxHp > 1 && hp > 0) {
    const hpW = (w - 6) * (hp / maxHp);
    ctx.fillStyle = '#ffaa0066';
    ctx.fillRect(x + 3, y + h - Math.round(5 * S), hpW, Math.round(3 * S));
  }

  // Tag text - scale font to fit box, with a readable minimum
  const charW = w / text.length;
  const fitSize = Math.floor(charW * 1.5);
  const fontSize = Math.max(fs(8), Math.min(fs(13), fitSize));
  ctx.font = `bold ${fontSize}px monospace`;
  ctx.fillStyle = baseColor;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  if (bad) {
    ctx.shadowColor = '#ff0044';
    ctx.shadowBlur = flash > 0 ? 10 : 4;
  } else {
    ctx.shadowColor = '#00ff88';
    ctx.shadowBlur = flash > 0 ? 8 : 3;
  }
  ctx.fillText(text, x + w / 2, y + h / 2 - (maxHp > 1 ? Math.round(2 * S) : 0));
  ctx.shadowBlur = 0;
}

function drawPlayer() {
  if (!player.alive) return;
  if (player.flash > 0 && Math.floor(player.flash / 3) % 2) return;

  const x = player.x;
  const y = player.y;
  const w = player.w;
  const h = player.h;

  ctx.fillStyle = '#00bbdd';
  ctx.beginPath();
  ctx.moveTo(x - w / 2, y + h / 2);
  ctx.lineTo(x - w / 2 + 6 * S, y - h / 2);
  ctx.lineTo(x + w / 2 - 6 * S, y - h / 2);
  ctx.lineTo(x + w / 2, y + h / 2);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#00eeff';
  ctx.fillRect(x - 2 * S, y - h / 2 - 8 * S, 4 * S, 10 * S);

  ctx.fillStyle = '#004455';
  ctx.fillRect(x - w / 2 + 8 * S, y - h / 2 + 3 * S, w - 16 * S, 4 * S);

  ctx.font = `bold ${fs(8)}px monospace`;
  ctx.fillStyle = '#001a22';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('<body>', x, y + 3 * S);

  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 10;
  ctx.strokeStyle = '#00ffff44';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - w / 2, y + h / 2);
  ctx.lineTo(x - w / 2 + 6 * S, y - h / 2);
  ctx.lineTo(x + w / 2 - 6 * S, y - h / 2);
  ctx.lineTo(x + w / 2, y + h / 2);
  ctx.closePath();
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.fillStyle = '#00ffff44';
  ctx.fillRect(x - 8 * S, y + h / 2, 4 * S, (3 + Math.random() * 4) * S);
  ctx.fillRect(x + 4 * S, y + h / 2, 4 * S, (3 + Math.random() * 4) * S);
}

function drawBullets() {
  for (const b of playerBullets) {
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 8;
    ctx.fillRect(b.x - 1.5 * S, b.y - 6 * S, 3 * S, 12 * S);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#00ffff';
    ctx.fillRect(b.x - 1 * S, b.y + 6 * S, 2 * S, 10 * S);
    ctx.globalAlpha = 0.1;
    ctx.fillRect(b.x - 0.5 * S, b.y + 16 * S, 1 * S, 8 * S);
    ctx.globalAlpha = 1;
  }

  for (const b of enemyBullets) {
    const color = b.bad ? '#ff4444' : '#ffcc00';
    ctx.fillStyle = color;
    ctx.shadowColor = color;
    ctx.shadowBlur = 5;
    ctx.fillRect(b.x - 2 * S, b.y - 5 * S, 4 * S, 10 * S);
    ctx.shadowBlur = 0;
    ctx.font = `${fs(8)}px monospace`;
    ctx.fillStyle = color + '88';
    ctx.textAlign = 'center';
    ctx.fillText(b.tag, b.x, b.y + 12 * S);
  }

  for (const d of saucerDrops) {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(Math.sin(d.wobble || 0) * 0.2);
    ctx.font = `bold ${fs(14)}px monospace`;
    ctx.fillStyle = '#ff3344';
    ctx.shadowColor = '#ff0022';
    ctx.shadowBlur = 8;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('<div>', 0, 0);
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

function drawSaucer() {
  if (!saucer) return;
  const x = saucer.x;
  const y = saucer.y;
  const pulse = 0.7 + Math.sin(Date.now() * 0.008) * 0.3;

  ctx.fillStyle = `rgba(255, 0, 255, ${pulse * 0.6})`;
  ctx.shadowColor = '#ff00ff';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.ellipse(x, y, saucer.w / 2, 11 * S, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#330033';
  ctx.shadowBlur = 0;
  ctx.beginPath();
  ctx.ellipse(x, y, saucer.w / 2 - 5 * S, 7 * S, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = `rgba(255, 0, 255, ${pulse * 0.4})`;
  ctx.beginPath();
  ctx.ellipse(x, y - 6 * S, 20 * S, 8 * S, 0, Math.PI, 0);
  ctx.fill();

  ctx.font = `bold ${fs(12)}px monospace`;
  ctx.fillStyle = '#ff66ff';
  ctx.shadowColor = '#ff00ff';
  ctx.shadowBlur = 8;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('<marquee>', x, y + 1);
  ctx.shadowBlur = 0;

  for (let i = 0; i < 5; i++) {
    const angle = (Date.now() * 0.005 + i * Math.PI * 2 / 5);
    const lx = x + Math.cos(angle) * (saucer.w / 2 - 3);
    const ly = y + Math.sin(angle) * 5 * S;
    ctx.fillStyle = i % 2 ? '#ff00ff' : '#ffff00';
    ctx.fillRect(lx - 1 * S, ly - 1 * S, 2 * S, 2 * S);
  }
}

function drawHUD() {
  // Responsive HUD layout
  const isNarrow = W < 600;
  const barW = isNarrow ? Math.min(W * 0.44, 200) : Math.min(180, W * 0.2);
  const barH = Math.round(16 * S);
  const hudY = Math.round(6 * S);
  const barGap = Math.round(4 * S);

  // Score
  ctx.font = `bold ${fs(14)}px monospace`;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(`SCORE ${score}`, Math.round(10 * S), hudY);

  // High score
  ctx.font = `${fs(10)}px monospace`;
  ctx.fillStyle = '#555';
  ctx.fillText(`HI ${highScore}`, Math.round(10 * S), hudY + fs(17));

  // Page + enemy count
  if (!isNarrow) {
    ctx.font = `bold ${fs(13)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#888';
    ctx.fillText(`PAGE ${wave}`, W / 2, hudY);

    const badLeft = enemies.filter(e => e.alive && e.bad).length;
    const goodLeft = enemies.filter(e => e.alive && !e.bad).length;
    ctx.font = `${fs(9)}px monospace`;
    ctx.fillStyle = '#ff4444';
    ctx.fillText(`BAD:${badLeft}`, W / 2 - 35 * S, hudY + fs(16));
    ctx.fillStyle = '#00cc66';
    ctx.fillText(`OK:${goodLeft}`, W / 2 + 35 * S, hudY + fs(16));
  }

  // --- Meters (top-right, or stacked on narrow) ---
  const tdX = W - barW - Math.round(10 * S);

  // Tech Debt meter
  ctx.fillStyle = '#111';
  ctx.fillRect(tdX, hudY, barW, barH);

  const tdPct = techDebt / 100;
  const tdFlash = techDebt > 75 && Math.floor(Date.now() / 300) % 2;
  let tdColor;
  if (techDebt > 75) tdColor = tdFlash ? '#ff0000' : '#cc0000';
  else if (techDebt > 50) tdColor = '#ff6600';
  else if (techDebt > 25) tdColor = '#ff8844';
  else tdColor = '#ff444488';

  ctx.fillStyle = tdColor;
  ctx.fillRect(tdX + 1, hudY + 1, (barW - 2) * tdPct, barH - 2);
  ctx.strokeStyle = techDebt > 75 ? '#ff0000' : '#444';
  ctx.lineWidth = 1;
  ctx.strokeRect(tdX, hudY, barW, barH);

  ctx.font = `bold ${fs(9)}px monospace`;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`DEBT ${Math.floor(techDebt)}%`, tdX + barW / 2, hudY + barH / 2);

  // Semantics meter
  const semY = hudY + barH + barGap;
  ctx.fillStyle = '#111';
  ctx.fillRect(tdX, semY, barW, barH);

  const semPct = semantics / 100;
  const semFlash = semantics < 25 && Math.floor(Date.now() / 300) % 2;
  let semColor;
  if (semantics < 25) semColor = semFlash ? '#ff4400' : '#cc3300';
  else if (semantics < 50) semColor = '#ddaa00';
  else semColor = '#00dd66';

  ctx.fillStyle = semColor;
  ctx.fillRect(tdX + 1, semY + 1, (barW - 2) * semPct, barH - 2);
  ctx.strokeStyle = semantics < 25 ? '#ff4400' : '#444';
  ctx.lineWidth = 1;
  ctx.strokeRect(tdX, semY, barW, barH);

  ctx.font = `bold ${fs(9)}px monospace`;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`SEM ${Math.floor(semantics)}%`, tdX + barW / 2, semY + barH / 2);

  // On narrow screens, show PAGE below meters
  if (isNarrow) {
    const badLeft = enemies.filter(e => e.alive && e.bad).length;
    ctx.font = `bold ${fs(10)}px monospace`;
    ctx.fillStyle = '#888';
    ctx.textAlign = 'center';
    ctx.fillText(`PAGE ${wave}  BAD:${badLeft}`, tdX + barW / 2, semY + barH + barGap + fs(6));
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    if (p.char) {
      ctx.font = `bold ${p.size}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.char, p.x, p.y);
    } else {
      ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    }
    ctx.restore();
  }
}

function drawFlashMessages() {
  for (const f of flashMessages) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, f.life);
    ctx.font = `bold ${fs(12)}px monospace`;
    ctx.fillStyle = f.color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = f.color;
    ctx.shadowBlur = 6;
    ctx.fillText(f.text, f.x, f.y);
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

function drawScanlines() {
  ctx.fillStyle = 'rgba(0,0,0,0.05)';
  for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);
}

// --- TITLE SCREEN ---
function drawTitleScreen() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  for (const s of titleStars) {
    s.y += s.speed;
    if (s.y > 1) { s.y = 0; s.x = Math.random(); }
    const bri = 40 + Math.sin(Date.now() * 0.003 + s.bright * 100) * 40;
    ctx.fillStyle = `rgb(${bri},${bri},${bri + 20})`;
    ctx.fillRect(s.x * W, s.y * H, 2, 2);
  }

  titleBlink++;

  const usableH = gameBottom;
  const cy = usableH * 0.18;

  // Big title - scales with screen width
  const titleSize = Math.min(fs(64), W * 0.1);
  ctx.font = `bold ${titleSize}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.fillStyle = '#440000';
  ctx.fillText('DIV VADERS', W / 2 + 3, cy + 3);

  ctx.shadowColor = '#ff0044';
  ctx.shadowBlur = 25;
  ctx.fillStyle = '#ff2244';
  ctx.fillText('DIV VADERS', W / 2, cy);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.font = `bold ${fs(12)}px monospace`;
  ctx.fillStyle = '#666';
  ctx.fillText('THE MARKUP BATTLE', W / 2, cy + titleSize * 0.65);

  // Enemy showcase
  const showY = cy + titleSize * 0.65 + fs(30);
  const lineup = [
    { tag: '<div>', color: '#ff2244', pts: '10', desc: 'ENEMY' },
    { tag: '<font>', color: '#ff6644', pts: '30', desc: 'OBSOLETE' },
    { tag: '<blink>', color: '#ff8844', pts: '30', desc: 'DEPRECATED' },
    { tag: '<marquee>', color: '#ff00ff', pts: '50', desc: 'SAUCER' },
  ];

  const lineH = fs(22);
  ctx.font = `${fs(11)}px monospace`;
  lineup.forEach((s, i) => {
    const sy = showY + i * lineH;
    ctx.fillStyle = s.color;
    ctx.textAlign = 'right';
    ctx.shadowColor = s.color;
    ctx.shadowBlur = 4;
    ctx.fillText(s.tag, W / 2 - fs(20), sy);
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#ffff00';
    ctx.textAlign = 'center';
    ctx.fillText(`${s.pts}`, W / 2 + fs(15), sy);
    ctx.fillStyle = '#555';
    ctx.textAlign = 'left';
    ctx.fillText(s.desc, W / 2 + fs(40), sy);
  });

  // Warning
  const warnY = showY + lineup.length * lineH + fs(18);
  ctx.font = `bold ${fs(11)}px monospace`;
  ctx.fillStyle = '#00ff88';
  ctx.textAlign = 'center';
  ctx.fillText('DON\'T SHOOT SEMANTIC TAGS!', W / 2, warnY);

  ctx.font = `${fs(9)}px monospace`;
  ctx.fillStyle = '#448866';
  const tagLine = W < 500
    ? '<header> <nav> <main> <article>'
    : '<header> <nav> <main> <article> <section> <aside> <footer>';
  ctx.fillText(tagLine, W / 2, warnY + fs(16));

  // Meter explanation
  const meterY = warnY + fs(36);
  ctx.font = `${fs(10)}px monospace`;
  ctx.fillStyle = '#ff4444';
  ctx.fillText('DEBT 100% + SEMANTICS 0% = GAME OVER', W / 2, meterY);
  ctx.fillStyle = '#00cc66';
  ctx.fillText('CLEAR A PAGE = -25% DEBT +25% SEM', W / 2, meterY + fs(16));

  // Start prompt
  if (Math.floor(titleBlink / 25) % 2) {
    ctx.font = `bold ${fs(20)}px monospace`;
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 15;
    const startText = isMobile ? 'TAP TO START' : 'PRESS SPACE TO START';
    ctx.fillText(startText, W / 2, usableH * 0.82);
    ctx.shadowBlur = 0;
  }

  // Controls
  if (!isMobile) {
    ctx.font = `${fs(10)}px monospace`;
    ctx.fillStyle = '#333';
    ctx.fillText('ARROWS / WASD = MOVE     SPACE = FIRE', W / 2, usableH * 0.90);
  }

  if (highScore > 0) {
    ctx.font = `${fs(10)}px monospace`;
    ctx.fillStyle = '#555';
    ctx.fillText(`HIGH SCORE: ${highScore}`, W / 2, usableH * 0.94);
  }

  drawScanlines();
}

// --- GAME OVER SCREEN ---
function drawGameOverScreen() {
  ctx.fillStyle = 'rgba(0,0,0,0.85)';
  ctx.fillRect(0, 0, W, H);

  const cy = gameBottom / 2;

  const goSize = Math.min(fs(52), W * 0.09);
  ctx.font = `bold ${goSize}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#ff0000';
  ctx.shadowColor = '#ff0000';
  ctx.shadowBlur = 20;
  ctx.fillText('GAME OVER', W / 2, cy - fs(50));
  ctx.shadowBlur = 0;

  ctx.font = `${fs(13)}px monospace`;
  ctx.fillStyle = '#ff4444';
  ctx.fillText('THE WEB HAS FALLEN TO DIV SOUP', W / 2, cy - fs(20));

  ctx.font = `${fs(10)}px monospace`;
  ctx.fillStyle = '#883333';
  ctx.fillText('VALIDITY EXTINGUISHED', W / 2, cy - fs(4));

  ctx.font = `bold ${fs(20)}px monospace`;
  ctx.fillStyle = '#fff';
  ctx.fillText(`SCORE: ${score}`, W / 2, cy + fs(25));

  ctx.font = `${fs(13)}px monospace`;
  ctx.fillStyle = '#888';
  ctx.fillText(`PAGES CLEARED: ${wave - 1}`, W / 2, cy + fs(48));

  if (score >= highScore && score > 0) {
    ctx.font = `bold ${fs(15)}px monospace`;
    ctx.fillStyle = '#ffff00';
    ctx.shadowColor = '#ffff00';
    ctx.shadowBlur = 8;
    ctx.fillText('NEW HIGH SCORE!', W / 2, cy + fs(72));
    ctx.shadowBlur = 0;
  }

  titleBlink++;
  if (Math.floor(titleBlink / 25) % 2) {
    ctx.font = `bold ${fs(16)}px monospace`;
    ctx.fillStyle = '#00ffff';
    const contText = isMobile ? 'TAP TO CONTINUE' : 'PRESS SPACE TO CONTINUE';
    ctx.fillText(contText, W / 2, cy + fs(100));
  }

  drawScanlines();
}

// --- WAVE CLEAR OVERLAY ---
function drawWaveClearOverlay() {
  ctx.fillStyle = 'rgba(0, 10, 5, 0.5)';
  ctx.fillRect(0, 0, W, H);

  const cy = gameBottom / 2;
  const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;

  const clearSize = Math.min(fs(44), W * 0.07);
  ctx.font = `bold ${clearSize}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = `rgba(0, 255, 136, ${pulse})`;
  ctx.shadowColor = '#00ff88';
  ctx.shadowBlur = 25;
  ctx.fillText(`PAGE ${wave} CLEARED!`, W / 2, cy - fs(20));
  ctx.shadowBlur = 0;

  ctx.font = `bold ${fs(15)}px monospace`;
  ctx.fillStyle = '#00ff88';
  ctx.fillText('VALID MARKUP RESTORED', W / 2, cy + fs(10));

  ctx.font = `${fs(13)}px monospace`;
  ctx.fillStyle = '#88ffaa';
  ctx.fillText('DEBT -25%   SEMANTICS +25%', W / 2, cy + fs(32));
}

// --- GAME FIELD ---
function drawGameField() {
  ctx.fillStyle = '#000008';
  ctx.fillRect(0, 0, W, H);

  // Subtle grid
  ctx.strokeStyle = '#080810';
  ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 50) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y < H; y += 50) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // Ground line - content zone
  const groundY = gameBottom - 8;
  ctx.strokeStyle = '#00ffff15';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(W, groundY);
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw enemies
  for (const e of enemies) {
    if (!e.alive) continue;
    const ex = formationX + e.localX;
    const ey = formationY + e.localY;
    drawTag(e.tag, ex, ey, e.w, e.h, e.bad, e.flash, e.hp, e.maxHp);
    if (e.flash > 0) e.flash--;
  }

  drawSaucer();
  drawBullets();
  drawPlayer();
  drawParticles();
  drawFlashMessages();
  drawHUD();
  drawScanlines();
}

// =====================================================================
// MAIN LOOP
// =====================================================================

function loop() {
  ctx.save();
  ctx.translate(shakeX, shakeY);

  switch (gameState) {
    case STATE.TITLE:
      drawTitleScreen();
      break;
    case STATE.PLAYING:
    case STATE.DYING:
      update();
      drawGameField();
      break;
    case STATE.WAVE_CLEAR:
      update();
      drawGameField();
      drawWaveClearOverlay();
      break;
    case STATE.GAME_OVER:
      drawGameField();
      drawGameOverScreen();
      break;
  }

  ctx.restore();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
