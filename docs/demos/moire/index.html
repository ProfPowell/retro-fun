<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Moire // RETRO FUN</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; cursor: crosshair; }
  canvas { display: block; }
  .back {
    position: fixed;
    top: 1rem;
    right: 1rem;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem; padding: 0.5rem;
    color: #333;
    text-decoration: none;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    z-index: 10;
  }
  .back:hover { color: #00ffff; }
</style>
</head>
<body>
<a class="back" href="../../">&larr; Back</a>
<canvas id="c"></canvas>
<script>
// Moire interference patterns - overlapping circle/line patterns
// that create mesmerizing color-cycling illusions
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

let mouseX = W / 2, mouseY = H / 2;
window.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

let time = 0;

// Multiple pattern generators
const patterns = [
  // Concentric circles from point
  (x, y, cx, cy) => {
    const d = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
    return Math.sin(d * 0.05);
  },
  // Radial lines from point
  (x, y, cx, cy) => {
    return Math.sin(Math.atan2(y - cy, x - cx) * 12);
  },
  // Horizontal waves
  (x, y, cx, cy) => {
    return Math.sin(y * 0.03 + Math.sin(x * 0.02) * 3);
  },
];

function draw() {
  const imageData = ctx.createImageData(W, H);
  const d = imageData.data;

  // Orbiting pattern centers
  const cx1 = W / 2 + Math.sin(time * 0.7) * W * 0.25;
  const cy1 = H / 2 + Math.cos(time * 0.5) * H * 0.25;
  const cx2 = mouseX;
  const cy2 = mouseY;
  const cx3 = W / 2 + Math.sin(time * 0.3 + 2) * W * 0.3;
  const cy3 = H / 2 + Math.cos(time * 0.8 + 1) * H * 0.3;

  const colorShift = time * 40;

  // Process every 2nd pixel for performance, fill in between
  const step = 2;
  for (let y = 0; y < H; y += step) {
    for (let x = 0; x < W; x += step) {
      // Layer 1: concentric circles from center 1
      const d1 = Math.sqrt((x - cx1) * (x - cx1) + (y - cy1) * (y - cy1));
      const v1 = Math.sin(d1 * 0.04 + time);

      // Layer 2: concentric circles from center 2 (mouse)
      const d2 = Math.sqrt((x - cx2) * (x - cx2) + (y - cy2) * (y - cy2));
      const v2 = Math.sin(d2 * 0.05 - time * 0.8);

      // Layer 3: radial pattern
      const angle = Math.atan2(y - cy3, x - cx3);
      const d3 = Math.sqrt((x - cx3) * (x - cx3) + (y - cy3) * (y - cy3));
      const v3 = Math.sin(angle * 8 + d3 * 0.02 + time * 1.5);

      // Combine patterns via interference
      const combined = (v1 + v2 + v3) / 3;

      // Map to color with cycling
      const hue = (combined * 180 + colorShift + d1 * 0.1) % 360;
      const sat = 80 + combined * 20;
      const light = 40 + combined * 30;

      // HSL to RGB (inline for speed)
      const h = hue / 360;
      const s = sat / 100;
      const l = light / 100;
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      const ri = Math.floor(r * 255);
      const gi = Math.floor(g * 255);
      const bi = Math.floor(b * 255);

      // Fill the step x step block
      for (let dy = 0; dy < step && y + dy < H; dy++) {
        for (let dx = 0; dx < step && x + dx < W; dx++) {
          const idx = ((y + dy) * W + (x + dx)) * 4;
          d[idx] = ri;
          d[idx + 1] = gi;
          d[idx + 2] = bi;
          d[idx + 3] = 255;
        }
      }
    }
  }

  ctx.putImageData(imageData, 0, 0);

  // Scanlines
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  for (let y = 0; y < H; y += 2) {
    ctx.fillRect(0, y, W, 1);
  }

  time += 0.016;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
