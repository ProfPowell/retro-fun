<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Type Paths // RETRO FUN</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0f; overflow: hidden; font-family: 'Courier New', monospace; }
  canvas { display: block; }
  .back {
    position: fixed; top: 1rem; right: 1rem;
    font-family: 'Courier New', monospace; font-size: 0.7rem;
    color: #444; text-decoration: none; letter-spacing: 0.15em;
    text-transform: uppercase; z-index: 10;
  }
  .back:hover { color: #ff00ff; }
  .controls {
    position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%);
    display: flex; gap: 0.75rem; z-index: 10; flex-wrap: wrap; justify-content: center;
  }
  .controls button {
    background: none; border: 1px solid #333; color: #666;
    font-family: 'Courier New', monospace; font-size: 0.65rem;
    padding: 0.4rem 0.8rem; cursor: pointer; letter-spacing: 0.1em; text-transform: uppercase;
  }
  .controls button:hover { border-color: #ff00ff; color: #ff00ff; }
  .controls button.active { border-color: #00ffff; color: #00ffff; }
</style>
</head>
<body>
<a class="back" href="../../">&larr; Back</a>
<div class="controls">
  <button class="active" data-shape="circle">Circle</button>
  <button data-shape="star">Star</button>
  <button data-shape="heart">Heart</button>
  <button data-shape="spiral">Spiral</button>
  <button data-shape="infinity">Infinity</button>
  <button data-shape="wave">Wave</button>
  <button data-shape="square">Square</button>
</div>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Shape path generators - return array of {x, y, angle} points
const shapes = {
  circle(word, cx, cy, r, count) {
    const pts = [];
    for (let i = 0; i < count; i++) {
      const t = (i / count) * Math.PI * 2;
      pts.push({ x: cx + Math.cos(t) * r, y: cy + Math.sin(t) * r, angle: t + Math.PI / 2 });
    }
    return pts;
  },
  star(word, cx, cy, r, count) {
    const pts = [];
    const spikes = 5;
    const innerR = r * 0.4;
    for (let i = 0; i < count; i++) {
      const t = (i / count) * Math.PI * 2 - Math.PI / 2;
      const spike = (i / count) * spikes * 2;
      const currentR = spike % 2 < 1
        ? innerR + (r - innerR) * (1 - (spike % 1))
        : innerR + (r - innerR) * (spike % 1);
      pts.push({ x: cx + Math.cos(t) * currentR, y: cy + Math.sin(t) * currentR, angle: t + Math.PI / 2 });
    }
    return pts;
  },
  heart(word, cx, cy, r, count) {
    const pts = [];
    for (let i = 0; i < count; i++) {
      const t = (i / count) * Math.PI * 2;
      const scale = r / 12;
      const hx = 16 * Math.pow(Math.sin(t), 3);
      const hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
      pts.push({ x: cx + hx * scale, y: cy + hy * scale, angle: Math.atan2(hy, hx) });
    }
    return pts;
  },
  spiral(word, cx, cy, r, count) {
    const pts = [];
    const turns = 3;
    for (let i = 0; i < count; i++) {
      const t = (i / count) * Math.PI * 2 * turns;
      const sr = (i / count) * r;
      pts.push({ x: cx + Math.cos(t) * sr, y: cy + Math.sin(t) * sr, angle: t + Math.PI / 2 });
    }
    return pts;
  },
  infinity(word, cx, cy, r, count) {
    const pts = [];
    for (let i = 0; i < count; i++) {
      const t = (i / count) * Math.PI * 2;
      const scale = r * 0.7;
      const ix = Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
      const iy = Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
      pts.push({ x: cx + ix * scale * 2, y: cy + iy * scale * 2, angle: t });
    }
    return pts;
  },
  wave(word, cx, cy, r, count) {
    const pts = [];
    for (let i = 0; i < count; i++) {
      const t = (i / count);
      const wx = cx - r + t * r * 2;
      const wy = cy + Math.sin(t * Math.PI * 4) * r * 0.4;
      const angle = Math.atan2(Math.cos(t * Math.PI * 4) * r * 0.4 * Math.PI * 4, r * 2);
      pts.push({ x: wx, y: wy, angle });
    }
    return pts;
  },
  square(word, cx, cy, r, count) {
    const pts = [];
    const half = r * 0.8;
    const perimeter = half * 8;
    for (let i = 0; i < count; i++) {
      const d = (i / count) * perimeter;
      let x, y, angle;
      if (d < half * 2) {
        x = cx - half + d; y = cy - half; angle = 0;
      } else if (d < half * 4) {
        x = cx + half; y = cy - half + (d - half * 2); angle = Math.PI / 2;
      } else if (d < half * 6) {
        x = cx + half - (d - half * 4); y = cy + half; angle = Math.PI;
      } else {
        x = cx - half; y = cy + half - (d - half * 6); angle = -Math.PI / 2;
      }
      pts.push({ x, y, angle });
    }
    return pts;
  }
};

let currentShape = 'circle';
let time = 0;
let targetPts = [];
let currentPts = [];
let transitioning = false;
let transitionProgress = 1;

const wordMap = {
  circle: 'CIRCLE',
  star: 'STAR',
  heart: 'HEART',
  spiral: 'SPIRAL',
  infinity: 'INFINITY',
  wave: 'WAVE',
  square: 'SQUARE'
};

function getShapePoints(shape) {
  const word = wordMap[shape];
  const cx = W / 2;
  const cy = H / 2;
  const r = Math.min(W, H) * 0.3;
  const charCount = 120;
  return { pts: shapes[shape](word, cx, cy, r, charCount), word };
}

function initShape(shape) {
  const { pts, word } = getShapePoints(shape);
  if (currentPts.length === 0) {
    currentPts = pts.map(p => ({ ...p }));
    targetPts = pts;
  } else {
    targetPts = pts;
    // Pad or trim to match lengths
    while (currentPts.length < targetPts.length) {
      currentPts.push({ ...currentPts[currentPts.length - 1] });
    }
    currentPts.length = targetPts.length;
    transitioning = true;
    transitionProgress = 0;
  }
  return word;
}

let currentWord = initShape(currentShape);

// Controls
document.querySelectorAll('.controls button').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    currentShape = this.dataset.shape;
    currentWord = initShape(currentShape);
  });
});

// Color palettes per shape
const colorSchemes = {
  circle:   ['#00ffff', '#0088ff', '#00ffcc'],
  star:     ['#ffff00', '#ff8800', '#ffcc00'],
  heart:    ['#ff0066', '#ff3388', '#ff0044'],
  spiral:   ['#ff00ff', '#8800ff', '#ff44ff'],
  infinity: ['#00ff88', '#00ffcc', '#88ff00'],
  wave:     ['#4488ff', '#00ccff', '#88aaff'],
  square:   ['#ff4400', '#ff8800', '#ffcc00'],
};

// Trail particles
const trails = [];

function draw() {
  ctx.fillStyle = 'rgba(10, 10, 15, 0.12)';
  ctx.fillRect(0, 0, W, H);

  // Transition animation
  if (transitioning) {
    transitionProgress += 0.025;
    if (transitionProgress >= 1) {
      transitionProgress = 1;
      transitioning = false;
    }
    const ease = transitionProgress < 0.5
      ? 4 * transitionProgress * transitionProgress * transitionProgress
      : 1 - Math.pow(-2 * transitionProgress + 2, 3) / 2;

    for (let i = 0; i < currentPts.length; i++) {
      if (targetPts[i]) {
        currentPts[i].x += (targetPts[i].x - currentPts[i].x) * ease * 0.1;
        currentPts[i].y += (targetPts[i].y - currentPts[i].y) * ease * 0.1;
        currentPts[i].angle += (targetPts[i].angle - currentPts[i].angle) * ease * 0.1;
      }
    }
  }

  const colors = colorSchemes[currentShape];
  const word = currentWord;
  const fontSize = Math.max(12, Math.min(W, H) * 0.025);

  // Draw connecting line
  ctx.beginPath();
  ctx.strokeStyle = colors[0] + '15';
  ctx.lineWidth = 1;
  for (let i = 0; i < currentPts.length; i++) {
    const p = currentPts[i];
    // Animate position along path
    const animOffset = Math.sin(time * 2 + i * 0.1) * 3;
    const ax = p.x + Math.cos(p.angle + Math.PI / 2) * animOffset;
    const ay = p.y + Math.sin(p.angle + Math.PI / 2) * animOffset;
    if (i === 0) ctx.moveTo(ax, ay);
    else ctx.lineTo(ax, ay);
  }
  ctx.stroke();

  // Draw characters
  for (let i = 0; i < currentPts.length; i++) {
    const p = currentPts[i];
    const charIdx = i % word.length;
    const ch = word[charIdx];

    // Animated wave offset
    const waveOffset = Math.sin(time * 3 + i * 0.15) * 4;
    const breathe = 1 + Math.sin(time * 1.5 + i * 0.08) * 0.15;

    const ax = p.x + Math.cos(p.angle + Math.PI / 2) * waveOffset;
    const ay = p.y + Math.sin(p.angle + Math.PI / 2) * waveOffset;

    // Color cycling through palette
    const colorIdx = Math.floor((i * 0.3 + time * 2) % colors.length);
    const nextColorIdx = (colorIdx + 1) % colors.length;

    // Size variation
    const sizeVar = fontSize * breathe;

    ctx.save();
    ctx.translate(ax, ay);
    ctx.rotate(p.angle);
    ctx.font = `bold ${sizeVar}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Glow
    ctx.shadowColor = colors[colorIdx];
    ctx.shadowBlur = 8 + Math.sin(time * 4 + i) * 4;
    ctx.fillStyle = colors[colorIdx];
    ctx.fillText(ch, 0, 0);

    ctx.shadowBlur = 0;
    ctx.restore();

    // Spawn trails occasionally
    if (Math.random() < 0.005) {
      trails.push({
        x: ax, y: ay, ch, color: colors[colorIdx],
        life: 1, vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5,
        size: sizeVar * 0.8
      });
    }
  }

  // Draw and update trails
  for (let i = trails.length - 1; i >= 0; i--) {
    const t = trails[i];
    t.life -= 0.008;
    t.x += t.vx;
    t.y += t.vy;
    if (t.life <= 0) { trails.splice(i, 1); continue; }

    ctx.save();
    ctx.globalAlpha = t.life * 0.4;
    ctx.font = `bold ${t.size}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = t.color;
    ctx.shadowColor = t.color;
    ctx.shadowBlur = 5;
    ctx.fillText(t.ch, t.x, t.y);
    ctx.restore();
  }
  if (trails.length > 200) trails.splice(0, trails.length - 200);

  // Shape label
  ctx.save();
  ctx.font = `bold ${fontSize * 3}px 'Courier New', monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = colors[0] + '0a';
  ctx.fillText(word, W / 2, H / 2);
  ctx.restore();

  time += 0.016;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
