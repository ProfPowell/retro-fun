<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Metaballs // RETRO FUN</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; cursor: crosshair; }
  canvas { display: block; image-rendering: pixelated; }
  .back {
    position: fixed;
    top: 1rem;
    right: 1rem;
    font-family: 'Courier New', monospace;
    font-size: 0.7rem;
    color: #333;
    text-decoration: none;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    z-index: 10;
  }
  .back:hover { color: #ff00ff; }
</style>
</head>
<body>
<a class="back" href="../../">&larr; Back</a>
<canvas id="c"></canvas>
<script>
// Metaballs - blobby organic shapes merging and splitting
// Classic demoscene effect from the Amiga era
// With heavy color cycling because we color cycle ALL THE THINGS
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const SCALE = 4;
let W, H, pw, ph, imageData;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  pw = Math.ceil(W / SCALE);
  ph = Math.ceil(H / SCALE);
  canvas.width = pw;
  canvas.height = ph;
  imageData = ctx.createImageData(pw, ph);
}
window.addEventListener('resize', resize);
resize();

// Balls
const NUM_BALLS = 8;
const balls = [];
for (let i = 0; i < NUM_BALLS; i++) {
  balls.push({
    x: Math.random(),
    y: Math.random(),
    vx: (Math.random() - 0.5) * 0.005,
    vy: (Math.random() - 0.5) * 0.005,
    radius: 40 + Math.random() * 60,
    phase: Math.random() * Math.PI * 2,
  });
}

// Mouse ball
let mouseX = 0.5, mouseY = 0.5;
window.addEventListener('mousemove', (e) => {
  mouseX = e.clientX / W;
  mouseY = e.clientY / H;
});

// Build multiple color palettes for cycling between them
function buildPalette(hueStart, hueEnd, cycles) {
  const pal = new Uint8Array(768); // 256 * 3
  for (let i = 0; i < 256; i++) {
    const t = i / 255;
    // Multiple sine waves for rich color cycling
    const hue = hueStart + (hueEnd - hueStart) * t + Math.sin(t * Math.PI * cycles) * 30;
    const sat = 0.8 + Math.sin(t * Math.PI * 2) * 0.2;
    const light = t * 0.8;

    // HSL to RGB
    const h = ((hue % 360) + 360) % 360 / 360;
    const s = sat;
    const l = light;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    pal[i * 3]     = Math.floor(r * 255);
    pal[i * 3 + 1] = Math.floor(g * 255);
    pal[i * 3 + 2] = Math.floor(b * 255);
  }
  return pal;
}

const palettes = [
  buildPalette(0, 60, 3),      // Fire
  buildPalette(180, 280, 2),   // Ocean
  buildPalette(90, 180, 4),    // Toxic
  buildPalette(270, 360, 3),   // Purple
  buildPalette(30, 200, 5),    // Rainbow
];

let time = 0;

function draw() {
  const d = imageData.data;

  // Update ball positions
  for (const ball of balls) {
    ball.x += ball.vx + Math.sin(time * 2 + ball.phase) * 0.002;
    ball.y += ball.vy + Math.cos(time * 1.5 + ball.phase) * 0.002;

    // Bounce
    if (ball.x < 0 || ball.x > 1) ball.vx *= -1;
    if (ball.y < 0 || ball.y > 1) ball.vy *= -1;
    ball.x = Math.max(0, Math.min(1, ball.x));
    ball.y = Math.max(0, Math.min(1, ball.y));

    // Pulsing radius
    ball.currentRadius = ball.radius * (1 + Math.sin(time * 3 + ball.phase) * 0.3);
  }

  // Current palette (blend between two)
  const palIdx = Math.floor(time * 0.3) % palettes.length;
  const nextPalIdx = (palIdx + 1) % palettes.length;
  const palBlend = (time * 0.3) % 1;
  const pal1 = palettes[palIdx];
  const pal2 = palettes[nextPalIdx];

  // Color cycling offset
  const colorOffset = Math.floor(time * 30) & 255;

  for (let y = 0; y < ph; y++) {
    for (let x = 0; x < pw; x++) {
      let sum = 0;

      // Sum contributions from all balls
      for (const ball of balls) {
        const bx = ball.x * pw;
        const by = ball.y * ph;
        const dx = x - bx;
        const dy = y - by;
        const distSq = dx * dx + dy * dy;
        sum += (ball.currentRadius * ball.currentRadius) / (distSq + 1);
      }

      // Mouse ball
      const mx = mouseX * pw;
      const my = mouseY * ph;
      const mdx = x - mx;
      const mdy = y - my;
      sum += 3000 / (mdx * mdx + mdy * mdy + 1);

      // Map to palette index with color cycling
      let palIndex = (Math.floor(sum * 4) + colorOffset) & 255;

      // Blend palettes
      const idx = (y * pw + x) * 4;
      const r1 = pal1[palIndex * 3];
      const g1 = pal1[palIndex * 3 + 1];
      const b1 = pal1[palIndex * 3 + 2];
      const r2 = pal2[palIndex * 3];
      const g2 = pal2[palIndex * 3 + 1];
      const b2 = pal2[palIndex * 3 + 2];

      d[idx]     = Math.floor(r1 * (1 - palBlend) + r2 * palBlend);
      d[idx + 1] = Math.floor(g1 * (1 - palBlend) + g2 * palBlend);
      d[idx + 2] = Math.floor(b1 * (1 - palBlend) + b2 * palBlend);
      d[idx + 3] = 255;
    }
  }

  ctx.putImageData(imageData, 0, 0);
  time += 0.016;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
